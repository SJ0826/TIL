# 검증 헤더와 조건부 요청

캐시 유효 시간이 초과해서 서버에 데이터를 다시 요청했을 때 **서버에서 기존 데이터를 변경하지 않은 경우**

데이터를 새로 전송하는 대신에 저장해 둔 캐시를 재사용할 수 있다.

이런 경우 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법이 필요하다.

- 검증 헤더: 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
- 조건부 요청 헤더: 검증 헤더로 조건에 따른 분기

조건부 요청 헤더와 검증 헤더의 조건이 만족하면 서버는 `200 OK`로 응답하고

조건이 맞지 않으면 `304 Not Modified`로 응답해 클라이언트의 캐시로 리다이렉션 한다.

## (방법 1) If-(Un)Modified-Since & Last-Modified

검증 헤더: `Last-Modified`<br>
조건부 요청 헤더: `If-Modified-Since`, `if-Unmodified-Since`
![image](https://user-images.githubusercontent.com/56298540/190891100-6337246d-5d04-46af-8ca0-2eb54ec66e69.png)

클라이언트의 데이터 요청에 서버가 응답을 할때 `Last-Modified`검증헤더를 추가한다.

`Last-Modified`는 마지막으로 데이터가 수정된 시간을 뜻한다.

![image](https://user-images.githubusercontent.com/56298540/190891164-230a2e9f-c99a-495e-8f66-57e5e8001573.png)

캐시 유효 시간이 초과되고 서버의 데이터가 갱신되지 않으면 클라이언트의 두번째 요청에 서버는 `304 Not Modified`로 응답한다.

이때 바디를 제외한 헤더의 메타 정보로만 응답한다.

클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신하고 캐시에 저장되어 있는 데이터를 재활용할 수 있다.

결과적으로 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드 할 수 있어 매우 실용적인 해결책이다.

### 단점

1. 1초 미만 단위로 캐시 조정이 불가능 하다
2. 날짜 기반의 로직을 사용해야 한다.
3. 데이터를 수정해서 날짜는 다르지만 같은 데이터를 수정해서 데이터의 결과가 똑같은 경우 비효율적인 작업이 된다.(예. 복사-붙여넣기)
4. 서버에서 별도의 캐시 로직을 관리할 수 없다.

이러한 단점을 커버하기 위해 `Etag`를 사용할 수 있다.

## (방법 2) if-(None)-Match & ETag

검증 헤더: `ETag`<br>
조건부 요청 헤더: `if-(None)-Match`

`Etag`는 Entity Tag로 **캐시용 데이터에 임의의 고유한 버전 이름**을 달아둔다.

데이터가 변경되면 이 이름을 바꾸어서 변경한다.

`ETag`를 보내서 이름이 같으면 유지하고 다르면 다시 받는다.

![image](https://user-images.githubusercontent.com/56298540/190891694-306ca96e-f960-4468-973b-f0e7718408cb.png)

웹 브라우저는 받은 `Etag: "aaaaaaaaaa"`를 캐시에 저장한다.

![image](https://user-images.githubusercontent.com/56298540/190891747-f6f32b96-1057-41b3-8af6-747feb7c60c6.png)

같은 이름의 `ETag`를 클라이언트와 서버가 가지고 있음을 알 수 있다.

데이터가 수정되지 않았으므로 서버는 `304 Not Modified`라는 메시지로 응답을 한다.

이때 HTTP 바디를 제외한 HTTP 헤더로만 응답을 한다.

`ETag`를 활용하면 캐시 제어 로직을 서버에서 완전히 관리하는 것이 가능하다.

## 출처

- [모든 개발자를 위한 HTTP 웹 기본 지식](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)
